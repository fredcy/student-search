module Main exposing (main)

import Html
import Html.Events as HE
import Html.Attributes as HA
import Http
import Json.Decode as Json
import String
import Task exposing (Task)
import Autocomplete


type alias Student =
    { firstName : String
    , lastName : String
    , number : String
    }


type alias StudentId =
    String


type alias Model =
    { students : List Student
    , selected : Maybe StudentId
    , query : String
    , showMenu : Bool
    , autoState : Autocomplete.State
    , httpError : Maybe Http.Error
    }


type Msg
    = NoOp
    | GotStudents (Result Http.Error (List Student))
    | QueryInput String
    | SelectStudent StudentId
    | PreviewStudent StudentId
    | AutocompleteMsg Autocomplete.Msg
    | HandleEscape
    | Wrap Bool
    | Reset


main =
    Html.programWithFlags
        { init = init
        , update = update
        , view = view
        , subscriptions = subscriptions
        }


type alias Flags =
    { service_url : String }


init : Flags -> ( Model, Cmd Msg )
init flags =
    ( Model [] Nothing "" False Autocomplete.empty Nothing
    , Http.send GotStudents (getStudents flags.service_url)
    )


howMany =
    10


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg |> Debug.log "msg" of
        GotStudents studentsResult ->
            case studentsResult of
                Ok students ->
                    { model | students = students } ! []

                Err httpError ->
                    { model | httpError = Just httpError } ! []

        QueryInput query ->
            -- user typed into selection box resulting in value `query`
            let
                showMenu =
                    not << List.isEmpty <| matchedStudents query model.students
            in
                { model | query = query, selected = Nothing, showMenu = showMenu } ! []

        AutocompleteMsg autoMsg ->
            -- msg generated by Autocomplete.view
            let
                choices =
                    matchedStudents model.query model.students

                ( newState, maybeMsg ) =
                    Autocomplete.update updateConfig autoMsg howMany model.autoState choices

                newModel =
                    { model | autoState = newState }
            in
                case maybeMsg of
                    Nothing ->
                        newModel ! []

                    Just updateMsg ->
                        update updateMsg newModel

        SelectStudent id ->
            -- student selected by mouse click or enter key (when item highlighted)
            (setQuery model id |> resetMenu) ! []

        PreviewStudent id ->
            -- student highlighted by mouseover or arrow key navigation
            { model | selected = Just id } ! []

        Reset ->
            { model | autoState = Autocomplete.reset updateConfig model.autoState, selected = Nothing } ! []

        Wrap toTop ->
            case model.selected of
                Just _ ->
                    update Reset model

                Nothing ->
                    let
                        choices =
                            matchedStudents model.query model.students

                        ( resetFn, reorderFn ) =
                            if toTop then
                                ( Autocomplete.resetToLastItem, List.reverse )
                            else
                                ( Autocomplete.resetToFirstItem, List.map identity )
                    in
                        { model
                            | autoState = resetFn updateConfig choices howMany model.autoState
                            , selected = (Maybe.map toId << List.head << reorderFn << List.take howMany) choices
                        }
                            ! []

        HandleEscape ->
            let
                haveMatches =
                    (not << List.isEmpty) (matchedStudents model.query model.students)

                model_ =
                    if haveMatches then
                        -- leave the query as is; not sure why but that's what the example code does
                        model |> removeSelection |> resetMenu
                    else
                        { model | query = "" } |> removeSelection |> resetMenu
            in
                model_ ! []

        NoOp ->
            model ! []


setQuery : Model -> StudentId -> Model
setQuery model id =
    let
        toQuery : Student -> String
        toQuery student =
            student.firstName ++ " " ++ student.lastName

        query =
            getById model.students id |> Maybe.map toQuery |> Maybe.withDefault "?"
    in
        { model | query = query, selected = Just id }


resetMenu : Model -> Model
resetMenu model =
    -- remove the auto-complete menu
    { model | autoState = Autocomplete.empty, showMenu = False }


removeSelection model =
    { model | selected = Nothing }


resetInput model =
    { model | query = "" } |> removeSelection |> resetMenu


view : Model -> Html.Html Msg
view model =
    Html.div []
        [ Html.h1 [] [ Html.text "Query example" ]
        , viewDebug model
        , viewAutocomplete model
        , Html.h2 [] [ Html.text "Next" ]
        ]


viewSelected : Maybe StudentId -> Html.Html Msg
viewSelected idMaybe =
    Html.div [] [ Html.text (toString idMaybe) ]


decodeKey : Json.Decoder Msg
decodeKey =
    HE.keyCode
        |> Json.andThen
            (\code ->
                let
                    _ =
                        Debug.log "code" code
                in
                    if code == 27 then
                        Json.succeed HandleEscape
                    else
                        Json.fail "ignoring this key here"
            )


viewAutocomplete : Model -> Html.Html Msg
viewAutocomplete model =
    let
        autoStyle =
            [ ( "display", "flex" )
            , ( "flex-direction", "column" )
            , ( "width", "250px" )
            ]

        options =
            { preventDefault = True, stopPropagation = False }

        inputValue =
            case model.selected of
                Nothing ->
                    model.query

                Just id ->
                    getById model.students id |> Maybe.map toDisplay |> Maybe.withDefault "*error*"

        choices =
            matchedStudents model.query model.students

        menu =
            if model.showMenu then
                Html.div [ HA.class "autocomplete-menu" ]
                    [ Html.map AutocompleteMsg (Autocomplete.view viewConfig howMany model.autoState choices)
                    ]
            else
                Html.text ""
    in
        Html.div [ HA.style autoStyle ]
            [ Html.input
                [ HE.onInput QueryInput
                , HA.class "autocomplete-input"
                , HA.value inputValue
                , HE.onWithOptions "keydown" options decodeKey
                ]
                []
            , menu
            ]


getById : List Student -> StudentId -> Maybe Student
getById students id =
    let
        matchesId student =
            toId student == id
    in
        students |> List.filter matchesId |> List.head


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.map AutocompleteMsg Autocomplete.subscription


getStudents : String -> Http.Request (List Student)
getStudents service_url =
    Http.get (service_url ++ "/students") studentsDecoder


studentsDecoder : Json.Decoder (List Student)
studentsDecoder =
    let
        student =
            Json.map3 Student
                (Json.field "FirstName" Json.string)
                (Json.field "LastName" Json.string)
                (Json.field "Number" Json.string)
    in
        Json.list student


tabKey =
    9


enterKey =
    13


arrowUpKey =
    38


arrowDownKey =
    40


updateConfig : Autocomplete.UpdateConfig Msg Student
updateConfig =
    let
        handleKey code maybeId =
            let
                _ =
                    Debug.log "key" ( code, maybeId )
            in
                if code == enterKey || code == tabKey then
                    Maybe.map SelectStudent maybeId
                else if code == arrowUpKey || code == arrowDownKey then
                    Maybe.map PreviewStudent maybeId
                else
                    --Just Reset
                    Nothing
    in
        Autocomplete.updateConfig
            { toId = toId
            , onKeyDown = handleKey
            , onTooLow = Just (Wrap False)
            , onTooHigh = Just (Wrap True)
            , onMouseEnter = Just << PreviewStudent
            , onMouseLeave = \_ -> Nothing
            , onMouseClick = Just << SelectStudent
            , separateSelections = False
            }


viewConfig : Autocomplete.ViewConfig Student
viewConfig =
    let
        customizedLi keySelected mouseSelected student =
            { attributes =
                [ HA.classList
                    [ ( "autocomplete-item", True )
                    , ( "key-selected", keySelected || mouseSelected )
                    ]
                ]
            , children = [ Html.text (toDisplay student) ]
            }
    in
        Autocomplete.viewConfig
            { toId = toId
            , ul = [ HA.class "autocomplete-list" ]
            , li = customizedLi
            }


viewDebug : Model -> Html.Html Msg
viewDebug { selected, query, showMenu, autoState, httpError } =
    -- Display all but model.students (since it is so large).
    (Html.text << toString)
        { selected = selected, query = query, showMenu = showMenu, autoState = autoState, httpError = httpError }


{-| Convert Student value to id value needed in Autocomplete.
-}
toId : Student -> StudentId
toId student =
    student.number


{-| Calculate the representation of a Student value as displayed to the user.
-}
toDisplay : Student -> String
toDisplay student =
    student.firstName ++ " " ++ student.lastName ++ " (" ++ student.number ++ ")"


{-| Filter the list of Students by matching to the given query. We match against
the `toDisplay` representation of each Student, ignoring case.
-}
matchedStudents : String -> List Student -> List Student
matchedStudents query students =
    let
        queryLower =
            String.toLower query
    in
        List.filter (String.contains queryLower << String.toLower << toDisplay) students
